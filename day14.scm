(import (srfi 1) (srfi 133) (data-structures))

(define (hash numbers lengths)
  (let* ((lengths (append lengths '(17 31 73 47 23)))
         (pos 0)
         (skip 0)
         (maxlen (vector-length numbers))
         (modadd (lambda args (remainder (apply + args) maxlen)))
         (moddecr (lambda (a) (if (= a 0) (- maxlen 1) (- a 1))))
         (reverse-section!
          (lambda (len)
            (let ((start pos)
                  (end (moddecr (modadd pos len)))
                  (endsteps (quotient len 2)))
              (do ((i start (modadd i 1))
                   (j end (moddecr j))
                   (steps 0 (+ steps 1)))
                  ((= steps endsteps))
                (vector-swap! numbers i j))
              (set! pos (modadd pos len skip))
              (set! skip (+ skip 1))))))
    (do ((i 0 (+ i 1)))
         ((= i 64))
      (for-each reverse-section! lengths))
    (let* ((blocks (chop (vector->list numbers) 16))
           (dense (map (cut reduce bitwise-xor #f <>) blocks)))
      (string-concatenate (map (cut format "~2,'0X" <>) dense)))))

(define (make-input seed row)
  (map char->integer (string->list (format "~A-~A" seed row))))

(define (to-bits n) (format "~4,0B" n))

(define (as-bits lst) (string-concatenate (map to-bits lst)))

(define (grid-ref grid x y)
  (vector-ref (vector-ref grid y) x))
                  
(define (grid-set! grid x y val)
  (vector-set! (vector-ref grid y) x val))

(define (fill-region! grid x y c)
  (grid-set! grid x y c)
  (if (and (> x 0) (eq? (grid-ref grid (- x 1) y) #t))
      (fill-region! grid (- x 1) y c))
  (if (and (< x 127) (eq? (grid-ref grid (+ x 1) y) #t))
      (fill-region! grid (+ x 1) y c))
  (if (and (> y 0) (eq? (grid-ref grid x (- y 1)) #t))
      (fill-region! grid x (- y 1) c))
  (if (and (< y 127) (eq? (grid-ref grid x (+ y 1)) #t))
      (fill-region! grid x (+ y 1) c)))
  
(define (count-regions grid)
  (let* ((grid (list->vector
                (map (lambda (line)
                       (list->vector
                        (map (lambda (c)
                               (if (char=? c #\1) #t #f))
                             (string->list (as-bits line)))))
                     grid)))
         (regions 0))
    (do ((x 0 (+ x 1)))
        ((= x 128) regions)
      (do ((y 0 (+ y 1)))
          ((= y 128))
        (when (eq? (grid-ref grid x y) #t)
              (set! regions (+ regions 1))
              (fill-region! grid x y regions))))))

(define c2n (map (lambda (c)
                   (cons c (string->number (string c) 16)))
                 (string->list "0123456789abcdef")))

(define (solve seed)
  (let loop ((n 0)
             (bits 0)
             (grid '()))
    (if (= n 128)
        (values bits (count-regions grid))
        (let* ((numbers (list->vector (iota 256)))
               (lengths (make-input seed n))
               (hashed (hash numbers lengths))
               (asnums (map (lambda (hexdigit)
                              (cdr (assq hexdigit c2n)))
                            (string->list hashed))))
          (loop (+ n 1)
                (+ bits (fold (lambda (n bits) (+ bits (bitwise-bit-count n)))
                              0 asnums))
                (cons asnums grid))))))

(format #t "Test 1: ~A~%" (solve "flqrgnkx"))
(format #t "Part 1: ~A~%" (solve "ffayrhll"))

        
